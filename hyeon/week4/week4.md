# 4주차 백준

---


## 1. 플로이드 문제 - 백준 11404번
    

### ❓문제 요약

- **목표**: 모든 도시의 쌍에 대해서 도시 A에서 B로 가는데 필요한 비용의 최솟값을 구하는 프로그램
- **자료구조**: 다익스트라 알고리즘, 플루이드-워셜 알고리즘
    - 문제 조건에 해당하는 버스 비용이 자연수이기 때문에 음수 가중치 간선이 없을 때 가장 효율적으로 동작하는 다익스트라 알고리즘을 사용
    - 모든 쌍의 최단 경로이기 때문에 플루이드-워셜 알고리즘과 유사
- **입력**
    - 첫째 줄: 도시의 개수를 나타내는 n
    - 둘째 줄: 버스의 개수를 나타내는 m
    - 셋째 줄부터: 버스의 정보 (버스의 시작 도시 a, 도착 도시 b, 한 번 타는데 필요한 비용 c )
- **제약 조건**
    - 비용은 100,000을 넘지 않는 자연수
    - 시작 도시와 도착 도시를 연결하는 노선은 하나가 아닐 수 있음
    - 시작 도시와 도착 도시가 같은 경우는 없음
- **출력**
    - n(도시의 개수)개의 줄을 출력.
        - i번째 줄에 출력하는 j번째 숫자는 도시 i에서 j로 가는데 필요한 최소 비용이다. 
        만약, i에서 j로 갈 수 없는 경우에는 그 자리에 0을 출력한다.

### ❗코드 설명

**변수**

- INF: 임의로 정한 거리 배열
    - 100개의 도시*100,000의 비용 감안한 최대값으로 지정
    - minDistance(최단거리)의 초기값 INF로 지정
- distance: 거리 배열
- found: 방문한 정점 의미하는 boolean 배열
- start: 시작 정점 / startCity: 시작 도시
- n: 전체 정점의 개수 / 도시의 개수
- u: 방문하지 않은 정점 중 distance가 가장 작은 정점
- weight: 시작 정점 ~ 각 정점의 최소 거리 배열
- m: 버스의 개수
- a: 시작 도시 / b: 도착 도시 / c: 비용
- result: 결과를 저장하는 배열

**코드 설명**

1. 다익스트라 알고리즘 설명
    - INF(최대값)로 distance 배열 초기화, distance의 시작 정점의 값 0
    - 먼저, n-1번 반복하며 최소 거리를 찾는다
        - -1로 초기화된 u 변수를 사용하여 최소값이 갱신될 때마다 저장하고, n-1번의 반복 중에서 u가 여전히 -1이라면 더 이상 연결된 경로가 없는 것으로 보고 종료
        - n-1번 반복이 끝난 정점은 방문한 것으로 표시한다
    - 다음으로, 선택된 정점을 거쳐 다른 정점으로 가는 거리를 갱신한다
        - 만약 선택된 정점에서 다른 정점으로 가는 간선이 있고, 다른 정점이 방문되지 않은 경우, 더 짧은 경로가 발견되었다면 갱신한다(INF가 아닌 경우에만)
2. 메인 함수 설명
    - 도시의 개수와 버스의 개수를 입력 받는다
    - 자기 자신으로의 거리는 0으로 두고 나머지 도시와의 거리 가중치는 INF로 둔다
    - 시작 도시와 도착 도시의 노선의 값을 입력받고 기존의 값과 비교하여 최소값만 가중치 배열에 저장한다
        - Math.min 함수 활용
    - 모든 도시에 대해 다익스트라 알고리즘 적용하고 해당값을 result 배열에 저장한다
    - 앞서 나온 결과를 바탕으로 최종 출력한다
        - 거리가 INF인 경우 0 출력하도록 함

---

## 2. 최단경로 문제 - 백준 1753번

### ❓문제 요약

- **목표**: 방향 그래프가 주어지면 주어진 시작점에서 다른 모든 정점으로의 최단 경로를 구하는 프로그램
- **자료구조**: 다익스트라 알고리즘
    - 문제 조건에 해당하는 정점 및 간선의 개수가 자연수이고 대규모이기 때문에 이를 처리할 때 가장 효율적으로 동작하는 다익스트라 알고리즘을 사용
- **입력**
    - 첫째 줄: 정점의 개수 V, 간선의 개수 E
    - 둘째 줄: 시작 정점의 번호 K(1 ≤ K ≤ V)
    - 셋째 줄부터: E개의 줄에 걸쳐 각 간선을 나타내는 세 개의 정수 (u, v, w)
        - u에서 v로 가는 가중치 w인 간선이 존재한다는 뜻
- **제약 조건**
    - 1 ≤ V(정점의개수) ≤ 20,000
    - 1 ≤ E(간선의 개수) ≤ 300,000
    - u와 v는 서로 다르며 w는 10 이하의 자연수
    - 서로 다른 두 정점 사이에 여러 개의 간선이 존재할 수도 있음
- **출력**
    - 첫째 줄부터 V개의 줄에 걸쳐, i번째 줄에 i번 정점으로의 최단 경로의 경로값을 출력한다.
        - 시작점 자신은 0으로 출력
        - 경로가 존재하지 않는 경우에는 INF를 출력

### ❗코드 설명

**변수**- INF: 문제의 최대경로 가중치보다 큰 값 (정점의 최대개수+1)
- distance: 거리를 저장하는 정수 배열
- pq: 우선순위 큐, 원소:{거리,정점} 저장 / 오름차순 정렬
- dist: 현재 정점까지의 최단 거리
- u: 현재 정점 인덱스
- nextV, vv: 도착 정점
- weight, w: 간선 가중치
- newDist: 새로운 경로의 거리(갱신)
- v: 정점의 개수, e: 간선의 개수, k: 시작 정점의 번호
- adj: 인접리스트

**코드 설명**

1. 다익스트라 알고리즘
    - INF로 거리 배열 초기화, 시작 정점 거리 0 지정
    - 우선순위 큐 pq 생성(거리, 정점) 후 오름차순 정렬 정의
        - pq에 시작 정점 삽입 (0, start)
    - 만약 pq가 비어있지 않다면 다익스트라 실행
        - 현재까지 확정된 정점 u 추출
        - 현재 확정 최단 거리보다 u의 거리가 긴 경우 무시
        - u와 연결된 모든 인접 정점 확인 후 현재 거리에 가중치 더해서 newDist에 저장, 만약 이 값이 더 짧다면 거리 갱신하고 큐에 삽입
2. 메인 함수
    - 정점, 간선의 개수와 시작 정점의 번호 입력
    - 인접 리스트를 초기화함
    - 시작정점, 도착정점, 가중치 입력받아 인접 리스트[도착 정점 인덱스, 가중치 형태]에 추가
    - 시작정점부터 다익스트라 실행
    - 최종 결과 출력
        - 거리로 INF값이 있는 경우 INF 출력, 아니면 cost 출력