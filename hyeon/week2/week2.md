# 2주차 백준

---


## 1. DFS와 BFS - 백준 1260번


### ❓문제 요약

- **목표**: 그래프를 DFS로 탐색한 결과와 BFS로 탐색한 결과를 출력하는 프로그램
- **자료구조**: DFS, BFS
- **입력**:
    - 첫째 줄: 정점(노드)의 개수N, 간선의 개수 M, 탐색 시작 정점 번호 V
    - 둘째 줄부터: M개의 명령 (간선이 연결하는 두 정점의 번호, 양방향)
- **제약 조건**:
    - 주어지는 정수 N은 1≤X≤1,000
    - 주어지는 정수 M은 1≤X≤10,000

### ❗코드 설명

**변수** 

- matrix: 그래프 정보를 담을 이중 행렬
- visited: 방문한 노드의 정보를 담을 boolean 배열
- N,M,V: 문제에서 주어진 변수
- q: BFS에서 탐색 순서를 저장할 큐 선언

**코드 해설**

1. 입력 받기 - BufferedReader 이용하여 입력을 받아옴
2. 입력받은 정보를 바탕으로 matrix 변수 생성 및 1로 초기화
3. visited 노드 초기화
4. DFS 진행하기
    - dfs 함수 재귀 호출
        - visited 변수 참으로 바꾸고 출력하기
        - 방문하지 않은 노드라면 연결된 모든 노드 방문(재귀 호출)
5. visited 노드 초기화
6. BFS 진행하기
    - bfs 함수 재귀 호출
        - 큐 이용, 시작 노드 큐에 추가 하고 방문 처리
        - 방문하지 않은 노드이고 연결된 노드라면 방문(재귀 호출)
            - 방문 후 제거하며 q가 빌 때까지 계속 반복

---

## 2. DFS 활용 - 백준 1987번

    

### ❓문제 요약

- **목표**: 세로 R칸, 가로 C칸의 표 모양 보드의 좌측에서 시작해서 말이 최대한 지나칠 수 있는 칸의 갯수를 구한다.
- **자료구조**: 처음부터 끝까지의 경로 탐색을 해야 하기 때문에 DFS 사용, 최적 경로 탐색을 위해 백트래킹 방식 추가 활용
- **이동 규칙**:
    1. 인접한 네 칸 중 한 칸으로 이동 가능
    2. 새로 이동한 칸에 적힌 알파벳은 지금까지의 알파벳과는 달라야 함
    3. 같은 알파벳이 적힌 칸을 두 번 지날 수 없음
- **입력**
    - 첫째 줄에는 가로(C)와 세로(R) 칸의 개수
    - 둘째 줄부터 R개의 줄에 걸쳐 보드에 적혀있는 C개의 대문자 알파벳 (빈칸X)
- **제약 조건**
    - R과 C는 1이상 20 이하의 수

### ❗코드 설명

**변수**

- R, C: 문제에서 주어진 세로칸과 가로칸
- board: R과 C 기반의 이중행렬
- max_count: 최대값을 측정하는 변수로, 출력에 해당
- visitedAlphabet: 지나간 알파벳 값을 기억하는 boolean 배열값
- startCharIndex: 보드의 시작 인덱스를 의미, 아스키코드의 구조에 따라 ‘A’를 빼어 정수값이 되도록 함
- count: 최대값과 비교하게 될 변수
- nextCharIndex: 보드의 상하좌우 방향의 값을 startCharIndex처럼 정수값으로 변경하여 저장함

**코드 해설**

1. R과 C, board 입력받기
    - R과 C 크기에 따라 board 변수를 생성하고, 입력받은 값을 저장
    - 시작하는 칸의 값을 startCharIndex로 지정하고 visitedAlphabet 값 변경
2. DFS 호출
    - 현재 입력된 count 값과 max_count을 비교하여 큰 값을 max_count로 지정
    - 만약 모든 값에 도달할 수 있다면 종료
    - 위쪽(board[r-1][c]) / 아래쪽(board[r+1][c]) / 왼쪽(board[r][c-1]) / 오른쪽(board[r][c+1]) 으로 이동 시도
        - 이때, 방문하지 않은 노드라면 visitedAlphabet 값을 변경하고, count 값을 하나 증가시킴
        - 상, 하, 좌, 우 이동이 가능한 방향이 있다면 끝까지 이동함
            - 이동이 불가능하다면 visitedAlphabet 값을 false로 두고 다른 방향으로 탐색을 지속함
    - 모든 값에 도달한다면 종료 / 상하좌우 모든 방향의 탐색이 종료되는 경우 종료