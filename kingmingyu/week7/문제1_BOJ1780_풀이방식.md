# 문제
N×N크기의 행렬로 표현되는 종이에서
1. 만약 종이가 모두 같은 수로 되어 있다면 이 종이를 그대로 사용한다.
2. (1)이 아닌 경우에는 종이를 같은 크기의 종이 9개로 자르고, 각각의 잘린 종이에 대해서 (1)의 과정을 반복한다.

-1로만 채워진 종이의 개수, 0으로만 채워진 종이의 개수, 1로만 채워진 종이의 개수를 구해내는 프로그램을 작성

## divde and conquer 이용
1. 첫번째 종이의 적힌 값을 저장
2. 모든 종이를 탐색하면서 만약 첫번째 종이와 값이 다르다면 종이를 3등분하기
3. 자른 종이의 크기가 1이 아니라면 1, 2동작을 반복

## 1. 종이 값 저장하기
```java
static int[][] paper;

paper = new int[N][N];
for(int i = 0; i < N; i++){
    StringTokenizer st = new StringTokenizer(br.readLine());
    for(int j = 0; j < N; j++){
        paper[i][j] = Integer.parseInt(st.nextToken());
    }
}
```
- 2차원 배열 paper에 입력받은 종이 저장

## 2. 종료 조건 설정하기
```java
if(n == 1){
    answer[paper[x][y] + 1]++;
    return;
}
```
- 만약 입력받은 종이의 크기가 1이라면 그 값에 해당하는 정답 +1

## 2. 종이에 적힌 값이 모두 같은지 확인하기
```java
int target = paper[x][y];
for(int i = x; i < x + n; i++){
    for(int j = y; j < y + n; j++){
        if(paper[i][j] != target){
            dnc(n/3, x, y);
            dnc(n/3, (x + n/3), y);
            dnc(n/3, (x + n/3 * 2), y);

            dnc(n/3, x, (y + n/3));
            dnc(n/3, (x + n/3), (y + n/3));
            dnc(n/3, (x + n/3 * 2), (y + n/3));

            dnc(n/3, x, (y + n/3 * 2));
            dnc(n/3, (x + n/3), (y + n/3 * 2));
            dnc(n/3, (x + n/3 * 2), (y + n/3 * 2));
            return;
        }
    }
}
answer[target + 1]++;
```
1. 첫번째 종이의 값을 target에 저장 `int target = paper[x][y]`
2. 종이의 크기만큼 반복문을 돌면서 값이 같은지 확인 `paper[i][j] != target`
3. 만약 종이의 값이 같지 않은 값이 들어있다면 종이 9등분하기
```java
dnc(n/3, x, y);
dnc(n/3, (x + n/3), y);
dnc(n/3, (x + n/3 * 2), y);

dnc(n/3, x, (y + n/3));
dnc(n/3, (x + n/3), (y + n/3));
dnc(n/3, (x + n/3 * 2), (y + n/3));

dnc(n/3, x, (y + n/3 * 2));
dnc(n/3, (x + n/3), (y + n/3 * 2));
dnc(n/3, (x + n/3 * 2), (y + n/3 * 2));
```
4. 만약 반복문 끝까지 왔다면 모든 종이에 적힌 값이 같다는 의미이므로 정답 +1 `answer[target + 1]++;`
