# 문제
2N × 2N인 2차원 배열을 Z모양으로 탐색할 때

N이 주어졌을 때, r행 c열을 몇 번째로 방문하는지 출력하는 프로그램을 작성하시오.

## divide and conquer 이용
1. 주어진 r, c의 값이 몇번째로 방문되는지 확인하기 위해 사분면 단위로 divde하며 이동
2. N의 크기가 1이 될 때 까지 반복

## 입력값
`public static int dnc(int N, int x, int y)`

크기 N, x좌표 시작 위치, y좌표 시작 위치

## 종료 조건
```java
if(N == 1){
    if(x == 1 && y == 1){
        cnt += 3;
        return cnt;
    }
    cnt = cnt + x + 2*y;
    return cnt;
}
```
만약 전달받은 N의 크기가 1이라면 x, y의 위치에 맞게 처리
1. x == 1 && y == 1 -> 3
2. x == 0 && y == 1 -> 2
3. x == 1 && y == 0 -> 1
4. x == 0 && y == 0 -> 0

## 사분면 단위로 나눠서 접근
```java
//제 1사분면
if(x < Math.pow(2, N-1) && y < Math.pow(2, N-1)){
    dnc(N -1, x, y);
}

//제 2사분면
else if(x >= Math.pow(2, N-1) && y < Math.pow(2, N-1)){
    cnt += Math.pow(Math.pow(2, N-1), 2);
    x -= Math.pow(2, N-1);
    dnc(N-1, x, y);
}

//제 3사분면
else if(x < Math.pow(2, N-1) && y >= Math.pow(2, N-1)){
    cnt += Math.pow(Math.pow(2, N-1), 2) * 2;
    y -= Math.pow(2, N-1);
    dnc(N-1, x, y);
}

//제 4사분면
else if(x >= Math.pow(2, N-1) && y >= Math.pow(2, N-1)){
    cnt += Math.pow(Math.pow(2, N-1), 2) * 3;
    x -= Math.pow(2, N-1);
    y -= Math.pow(2, N-1);
    dnc(N-1, x, y);
}
```
1. `Math.pow(2, N-1)` -> 입력 받은 N의 중간 값 (ex. N = 3이라면 2^3크기의 정사각형이므로 2^2가 중간 위치)
    `Math.pow(2, N-1)`을 기준으로 몇사분면에 위치한지 판단


2. x, y값의 보정 -> 만약 1사분면이  아닌 사분면에 위치했다면 x, y값을 보정하기

    `x -= Math.pow(2, N-1)` or `y -= Math.pow(2, N-1)` -> 재귀 호출 시 다시 1사분면에 위치시키기 위해


3. 이동거리 보정
    
    2사분면: `cnt += Math.pow(Math.pow(2, N-1), 2)`와 같이 Z방향에 따라 사분면의 크기만큼 증가시켜주기
    
