# 문제
(n X m) 크기의 map에서 서로 다른 알바벳을 밟고 지나갈 수 있는 최대 path의 길이

ex)
```java
5 5
IEFCJ
FHFKC
FFALF
HFGCF
HMCHH
```
I -> E -> H -> F -> K -> L -> A -> G -> C -> M (10 출력)

# 자료 구조
- 최대 길이를 출력하기 위해 DFS 이용
- DFS 방문 배열을 나타내기 위한 visited boolean 배열
- map을 탐색하기 위해 x, y 방향으로 한 칸씩 이동할 수 있는 배열

# 풀이
1. 자료구조 및 데이터 입력 받기
- 전역 변수
```java
    static boolean visited[] = new boolean[26]; //dfs를 위한 boolean 배열
    static char[][] alpha; // 입력받은 알파벳 map 그래프
    static int dx[] = {-1, 0, 1, 0}; // x방향으로 이동
    static int dy[] = {0, 1, 0, -1}; // y방향으로 이동
    static int n, m; // 그래프의 최대 크기
    static int max; // 가장 깊게 이동한 경우
```
- 메인 함수
```java
        StringTokenizer st = new StringTokenizer(br.readLine());

        n = Integer.parseInt(st.nextToken());
        m = Integer.parseInt(st.nextToken());

        alpha = new char[n][m];

        for(int i = 0; i < n; i++){
            String line = br.readLine();
            for(int j = 0; j < m; j++){
                alpha[i][j] = line.charAt(j);
            }
        }
```
2. map 그래프에서 dfs 구현
```java
static public void dfs(int x, int y){
        visited[alpha[x][y] - 'A'] = true;

        for(int i = 0; i < 4; i++){
            int nx = x + dx[i];
            int ny = y + dy[i];
            
            // map 그래프이므로 map을 벗어나는 경우 제외시키기
            // (0보다 작아지거나, 그래프의 최대 크기보다 커지는 경우)
            if(nx >= 0 && nx < n && ny >= 0 && ny < m){
                if(visited[alpha[nx][ny] - 'A'] == false){
                    dfs(nx, ny, dist+1);
                }
            }
        }
    }
```
3. 최장 길이 문자열 찾기
- 최장 길이의 문자열을 찾기 위해 dist 매개변수 추가
- 가장 깊게 간 경우를 탐색하기 위해 if문 추가
- 한 방향으로 탐색이 끝나고 다른 방향으로 가는 경우를 다시 탐색하기 위해 방문한 visited를 false로 변경
```java
static public void dfs(int x, int y, int dist){
        visited[alpha[x][y] - 'A'] = true;

        // 가장 깊게 간 경우를 저장하기 위해 추가
        if(dist > max){
            max = dist;
        }

        for(int i = 0; i < 4; i++){
            int nx = x + dx[i];
            int ny = y + dy[i];
            if(nx >= 0 && nx < n && ny >= 0 && ny < m){
                if(visited[alpha[nx][ny] - 'A'] == false){
                    dfs(nx, ny, dist+1);
                    // 한 방향으로 탐색이 끝나고 다른 방향으로 가는 경우를 다시 탐색하기 위해 추가
                    visited[alpha[nx][ny] - 'A'] = false; 
                }
            }
        }
    }
```

# 전체 코드
```java
package kingmingyu.week2;

import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.StringTokenizer;

public class 문제2_BOJ1987_풀이 {

    static boolean visited[] = new boolean[26];
    static char[][] alpha; // 입력받은 알파벳 map 그래프
    static int dx[] = {-1, 0, 1, 0}; // x방향으로 이동
    static int dy[] = {0, 1, 0, -1}; // y방향으로 이동
    static int n, m; // 그래프의 최대 크기
    static int max; // 가장 깊게 이동한 경우

    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));

        StringTokenizer st = new StringTokenizer(br.readLine());

        n = Integer.parseInt(st.nextToken());
        m = Integer.parseInt(st.nextToken());

        alpha = new char[n][m];

        for(int i = 0; i < n; i++){
            String line = br.readLine();
            for(int j = 0; j < m; j++){
                alpha[i][j] = line.charAt(j);
            }
        }

        max = 0;
        dfs(0, 0, 1);

        System.out.print(max);

    }
    static public void dfs(int x, int y, int dist){
        visited[alpha[x][y] - 'A'] = true;

        if(dist > max){
            max = dist;
        }

        for(int i = 0; i < 4; i++){
            int nx = x + dx[i];
            int ny = y + dy[i];
            if(nx >= 0 && nx < n && ny >= 0 && ny < m){
                if(visited[alpha[nx][ny] - 'A'] == false){
                    dfs(nx, ny, dist+1);
                    visited[alpha[nx][ny] - 'A'] = false;
                }
            }
        }
    }
}

```