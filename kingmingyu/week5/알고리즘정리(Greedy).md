## **그리디 알고리즘(탐욕법, Greedy Algorithm)**

- ‘**각 단계에서 최적이라고 생각되는 것을 선택**’ 해 나가는 방식으로 진행하여 최종적인 해답에 도달하는 알고리즘
- 항상 최적의 값을 보장하는것이 아니라 최적의 값의 ‘근사한 값’을 목표
- 주로 문제를 분할 가능한 문제들로 분할한 뒤, 각 문제들에 대한 최적해를 구한 뒤 이를 결합하여 전체 문제의 최적해를 구하는 경우에 주로 사용
    
    

### 동작 예시

[문제] 노드에서 가장 합이 높은 방법을 선택하는 방법 구하기

각각 상황에서 '최적'이라고 생각하는 방법을 선택( = 각 상황에서 가장 높은 수를 선택)

<img width="1061" height="565" alt="Image" src="https://github.com/user-attachments/assets/12d48965-f016-4964-bc5b-bd26e2b92cd9" />

## **그리디 알고리즘 주요 속성**

두 가지 조건이 성립해야 그리디 알고리즘을 적용 가능

**1. 탐욕 선택 속성(Greedy Choice Property)**

각 단계에서 **‘최선의 선택’을 했을 때 전체 문제에 대한 최적해를 구할 수 있는 경우**

**2. 최적 부분 구조(Optimal Substructure)**

**전체 문제의 최적해가 ‘부분 문제의 최적해로 구성’**될 수 있는 경우

## **그리디 알고리즘 단계**

그리디 알고리즘의 단계는 매 단계마다 최적이라고 생각되는 선택을 하면서 최종적으로 전체적으로 최적인 해답을 찾아내는 과정을 의미

1. **선택 절차(Selection Procedure) →** 현재 상태에서 최적인 선택
2. **적절성 검사(Feasibility Check) →** 선택한 항목이 ‘문제의 조건’을 만족시키는지 확인
3. **해답 검사(Solution Check) →** 모든 선택이 완료되면, ‘최종 선택’이 ‘문제의 조건을 만족’시키는지 확인

## **그리디 알고리즘 vs 동적 계획법**

| **분류** | **그리디 알고리즘 (Greedy Algorithm)** | **동적 계획법 (DP, Dynamic Programming)** |
| --- | --- | --- |
| **설명** | 매 순간 **가장 좋아 보이는 선택**을 하면서 문제를 푸는 방법 | 문제를 **작은 부분으로 나눠서**, 이미 계산한 결과를 **저장하고 재활용**하면서 푸는 방법 |
| **조건** | 1. **탐욕 선택 속성**: 지금의 최선 선택이 전체에서도 최선이어야 함2. **최적 부분 구조**: 큰 문제의 해답이 작은 문제의 해답으로부터 만들어질 수 있어야 함 | 1. **중복 부분 문제**: 같은 계산이 여러 번 반복됨2. **최적 부분 구조**: 큰 문제의 해답이 작은 문제의 해답으로부터 만들어질 수 있어야 함 |
| **중복 계산** | 같은 계산을 여러 번 하더라도 **기억하지 않음** | 같은 계산을 여러 번 하지 않기 위해 **결과를 저장함** |
| **특징 / 상황** | - 그때그때 최선의 선택을 함- 빠르게 답을 구할 수 있지만, **항상 최적해는 아닐 수 있음** | - 모든 경우를 고려해서 답을 구함- **항상 최적의 해를 구할 수 있지만**, 계산이 오래 걸림 |