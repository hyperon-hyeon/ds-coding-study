# 문제
문서를 입력받아 **우선순위에 맞게** 출력하는 과정에서 **찾는 문서의 idx가 몇번 째에 인쇄**되는지 출력하는 문제

-> 우선순위에 맞게 출력하기 위해 `우선순위 큐` 이용 (현재 문서가 우선순위가 가장 높은지 비교)

-> 입력받은 문서들을 저장하기 위해 `큐` 이용 ( [문서 idx, 우선순위] 저장 + 우선순위에 맞지 않는다면 가장 뒤로 보내기 위해)
## 실수
1. 문서의 idx를 저장하지 않아 while문을 종료시킬 조건을 작성하지 못함
    
- Queue<Integer> queue = new LinkedList<>(); -> Queue<int[]> queue = new LinkedList<>(); 로 변경 (문서 idx와 우선순위를 함께 저장하기 위해)
2. br.readLine()을 잘못 사용하여 오류 발생
- 변경 전
```java
int docN = Integer.parseInt(br.readLine()); // 여기서 "1 0"과 같은 한 줄을 통째로 읽어 에러 발생
int findDocIdx = Integer.parseInt(br.readLine());
```
- 변경 후
```java
StringTokenizer st = new StringTokenizer(br.readLine());
int docN = Integer.parseInt(st.nextToken());
int findDocIdx = Integer.parseInt(st.nextToken());
```

# 전체 코드
```java
package kingmingyu.week1;

import java.io.*;
import java.util.*;

public class 문제2_BOJ1966_풀이 {
    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));

        int n = Integer.parseInt(br.readLine());

        for(int i = 0; i < n; i++){
            PriorityQueue<Integer> pQ = new PriorityQueue<>(Collections.reverseOrder()); // 우선순위를 저장할 우선순위 큐(큰 수 우선)
            Queue<int[]> queue = new LinkedList<>(); // [문서 인덱스, 문서 우선순위] 저장할 큐

            //문서 자료구조에 저장
            StringTokenizer st = new StringTokenizer(br.readLine());
            int docN = Integer.parseInt(st.nextToken());
            int findDocIdx = Integer.parseInt(st.nextToken());

            st = new StringTokenizer(br.readLine());
            for(int j = 0; j < docN; j++){
                int doc = Integer.parseInt(st.nextToken());
                pQ.add(doc);
                queue.add(new int[]{j, doc});
            }

            int printDoc = 0; //출력한 문서 개수
            while(!queue.isEmpty()){
                int[] curDoc = queue.poll(); // 현재 출력할 문서
                if(curDoc[1] == pQ.peek()){ // 우선순위가 가장 높다면
                    printDoc++;
                    pQ.poll();
                    if(curDoc[0] == findDocIdx)
                        break;
                }
                else { queue.add(curDoc); }
            }

            System.out.println(printDoc);
        }
    }
}

```
