## **1. 다익스트라 (Dijkstra) 알고리즘**

그래프 상에서 특정 한 노드에서 다른 모든 노드까지의 최단거리를 구하는 알고리즘(가중 그래프에서 간선 가중치의 합이 최소가 되는 경로를 찾는 알고리즘)

시간 복잡도: O((V + E)log V)

- 다익스트라 = 그리디 + 동적 계획법 (현재 위치한 노드에서 최선의 경로를 반복적으로 찾으면서도 계산 해둔 경로를 활용해 중복된 하위 문제를 풀기 때문)
- 다익스트라는 만약 그래프에 음의 가중치가 있다면 사용X (그리디를 통해 최단 경로라고 여겨진 경로 비용을 DP 테이블에 저장한 뒤, 재방문하지 않는데, 만약 음의 가중치가 있다면 이러한 규칙이 어긋날 수 있기 때문)

### 동작 예시

- 초기 테이블 및 가중치

<img width="522" height="418" alt="Image" src="https://github.com/user-attachments/assets/9d11c730-a9bf-48c2-b6a2-acfed25c8876" />

| 0 | 3 | INF | 8 | 9 |
| --- | --- | --- | --- | --- |
| 3 | 0 | 2 | INF | INF |
| INF | 2 | 0 | 1 | 3 |
| 8 | INF | 1 | 0 | INF |
| 9 | INF | 3 | INF | 0 |
- 특정 한 노드를 1이라 가정하면 [0, 3, INF, 8, 9]는 다음과 같은 과정을 통해 업데이트 된다.
    
    
    | 0 | 3 | INF | 8 | 9 |
    | --- | --- | --- | --- | --- |
1. 노드 1을 선택하게 되면 1과 연결된 3개의 간선을 확인한다.
2. 이 중에서 다른 정점으로 가는 최소 비용이 2번 노드가 가장 작기 때문에 2번 노드로 이동, 노드 1번은 방문 처리(테이블 값 변화 X)
3. 방문 처리 되지 않았고 최소 비용으로 연결된  노드 3으로 이동, 2를 방문 처리 한다. 그리디와 같이 계속해서 최적의 상태를 업데이트 하므로 3을 방문할 수 있기 때문에 1 → 2 → 3으로 이동하는 동안의 비용인 5로 업데이트 해준다.
    
    
    | 0 | 3 | **5** | 8 | 9 |
    | --- | --- | --- | --- | --- |
4. 마찬가지로 방문 처리 되지 않고 최소 비용으로 연결된 노드 4로 이동, 3을 방문 처리한다. 기존에는 1 → 4로 가는 비용이 8이었지만 1 → 2 → 3 → 4를 거치는 것이 6이 들기에 테이블 값을 6으로 업데이트
    
    
    | 0 | 3 | 5 | **6** | 9 |
    | --- | --- | --- | --- | --- |
5. 우선순위 큐에 저장된 값 중에서 가장 작은 값인 3 (3 → 5)을 탐색하고 5번 노드도 방문처리 해준다. 이 때 가중치의 합이 더 작으므로 8로 업데이트 해준다. 그럼 모든 모드가 방문 처리가 완료 되었으므로 알고리즘이 종료된다.
    
    
    | 0 | 3 | 5 | 6 | **8** |
    | --- | --- | --- | --- | --- |

### 구현(Java)

```java
package Graph;

import java.util.ArrayList;
import java.util.Scanner;

/*
sample input
5 6
1
5 1 1
1 2 2
1 3 3
2 3 4
2 4 5
3 4 6
 */

// 도착 지점과, 도착지점으로 가는 비용을 의미하는 클래스를 정의한다.
class Node {
	int idx;
	int cost;

	// 생성자
	Node(int idx, int cost) {
		this.idx = idx;
		this.cost = cost;
	}
}

public class Dijkstra {
	public static void main(String[] args) {
		Scanner sc = new Scanner(System.in);
		// 노드와 간선의 개수
		int V = sc.nextInt();
		int E = sc.nextInt();
		// 출발지점
		int start = sc.nextInt();

		// 1. 인접리스트를 이용한 그래프 초기화
		ArrayList<ArrayList<Node>> graph = new ArrayList<ArrayList<Node>>();
		// 노드의 번호가 1부터 시작하므로, 0번 인덱스 부분을 임의로 만들어 놓기만 한다.
		for (int i = 0; i < V + 1; i++) {
			graph.add(new ArrayList<>());
		}
		// 그래프에 값을 넣는다.
		for (int i = 0; i < E; i++) {
			// a로 부터 b로 가는 값은 cost이다.
			int a = sc.nextInt();
			int b = sc.nextInt();
			int cost = sc.nextInt();

			graph.get(a).add(new Node(b, cost));
		}

		// 2. 방문 여부를 확인할 boolean 배열, start 노드부터 end 노드 까지의 최소 거리를 저장할 배열을 만든다.
		boolean[] visited = new boolean[V + 1];
		int[] dist = new int[V + 1];

		// 3. 최소 거리 정보를 담을 배열을 초기화 한다.
		for (int i = 0; i < V + 1; i++) {
			// 출발 지점 외 나머지 지점까지의 최소 비용은 최대로 지정해둔다.
			dist[i] = Integer.MAX_VALUE;
		}
		// 출발 지점의 비용은 0으로 시작한다.
		dist[start] = 0;

		// 4. 다익스트라 알고리즘을 진행한다.
		// 모든 노드을 방문하면 종료하기 때문에, 노드의 개수 만큼만 반복을 한다.
		for (int i = 0; i < V; i++) {
			// 4 - 1. 현재 거리 비용 중 최소인 지점을 선택한다.
			// 해당 노드가 가지고 있는 현재 비용.
			int nodeValue = Integer.MAX_VALUE;
			// 해당 노드의 인덱스(번호).
			int nodeIdx = 0;
			// 인덱스 0은 생각하지 않기 때문에 0부터 반복을 진행한다.
			for (int j = 1; j < V + 1; j++) {
				// 해당 노드를 방문하지 않았고, 현재 모든 거리비용 중 최솟값을 찾는다.
				if (!visited[j] && dist[j] < nodeValue) {
					nodeValue = dist[j];
					nodeIdx = j;
				}
			}
			// 최종 선택된 노드를 방문처리 한다.
			visited[nodeIdx] = true;

			// 4 - 2. 해당 지점을 기준으로 인접 노드의 최소 거리 값을 갱신한다.
			for (int j = 0; j < graph.get(nodeIdx).size(); j++) {
				// 인접 노드를 선택한다.
				Node adjNode = graph.get(nodeIdx).get(j);
				// 인접 노드가 현재 가지는 최소 비용과
				// 현재 선택된 노드의 값 + 현재 노드에서 인접 노드로 가는 값을 비교하여 더 작은 값으로 갱신한다.
				if (dist[adjNode.idx] > dist[nodeIdx] + adjNode.cost) {
					dist[adjNode.idx] = dist[nodeIdx] + adjNode.cost;
				}
			}
		}

		// 5. 최종 비용을 출력한다.
		for (int i = 1; i < V + 1; i++) {
			if (dist[i] == Integer.MAX_VALUE) {
				System.out.println("INF");
			} else {
				System.out.println(dist[i]);
			}
		}
		sc.close();
	}
}
```

## **2. 벨만 포드 (Bellman Ford) 알고리즘**

가중 유향 그래프 상에서 특정 한 노드로 부터 다른 노드까지의 최단 경로를 구하는 알고리즘 (사이클을 형성한 그래프에서 간선이 음수일 때 최단 경로를 구할 수 없다는 다익스트라 알고리즘의 한계점을 보완하기 위해 등장)

시간 복잡도: O(V E)

<img width="546" height="198" alt="Image" src="https://github.com/user-attachments/assets/041d77f3-24bf-4732-957d-ba9a95e21cf3" />

- **다익스트라 알고리즘**
    
    가중치 3 → 4 → 5를 거쳐 비용이 12가 된다. 하지만 중간에 사이클이 있기 때문에 3 → 4 → -6 → 4 → -6 → 4 → -6 ...이 되어 비용이 무한히 작아지게 된다.
    
- **벨만 포드**
    
    기본적으로 다익스트라와 동일, 핵심 차이점은 간선의 가중치가 음일 때도 최소 비용을 구하기O 다만 시간복잡도가 늘어나기 때문에 **가중치가 모두 양수일 경우 다익스트라를 사용하는 것이 좋다 (**그리디하게 최소 비용 경로를 찾아가는 다익스트라와 달리, 벨만 포드는 모든 경우의 수를 고려하는 **동적 계획법**이 사용되기 때문)
    
    모든 경우의 수를 고려하기 → 매 단계 마다 모든 간선을 전부 확인하기
    
    **다익스트라**는 출발 노드에서만 연결된 노드를 반복적으로 탐색하며 다른 모든 노드까지의 최소 거리를 구함
    
    **벨만 포드**는 모든 노드가 한번씩 출발점이 되어 다른 노드까지의 최소 비용을 구함.
    

### 동작 예시

<img width="342" height="327" alt="Image" src="https://github.com/user-attachments/assets/0e414ee6-3821-48c9-922c-4eb620a3f3ab" />

모든 노드가 한 번씩 출발 노드가 됨. Itertation 1회, 2회일 때를 이해하면 귀납적으로 적용

위와 같은 초기 상태의 그래프가 있을 때, 가중치를 담을 DP 테이블 값은 아래와 같이 모두 INF가 된다.

| INF | INF | INF | INF | INF |
| --- | --- | --- | --- | --- |

1. 첫 번째로 **노드 1번**을 먼저 탐색

    | 0 | -6 | 3 | 9 | 8 |
    | --- | --- | --- | --- | --- |

2. **2번 노드**, 2번 노드는 3번과 연결
    
    1 → 3 경로 비용인 3보다 1 → 2 → 3 경로 비용인 -8이 더 작으므로 DP 테이블 값을 3에서 -8로 업데이트 해준다.
    
    | 0 | -6 | **-8** | 9 | 8 |
    | --- | --- | --- | --- | --- |
3. **3번 노드**, 4번과 5번 노드에 연결되어 있다.
    
    1 → 4 비용인 9보다 1 → 2 → 3 → 4 비용인 -3이 작으므로 9를 -3으로 업데이트 해준다.
    
    | 0 | -6 | -8 | **-3** | 8 |
    | --- | --- | --- | --- | --- |
    
    또 1 → 5 비용인 8보다 1 → 2 → 3 → 5 비용인 -15가 작으므로 8을 -15로 업데이트 해준다.
    
    | 0 | -6 | -8 | **-3** | **-15** |
    | --- | --- | --- | --- | --- |

4. **4번 노드,** 3번 노드와 연결되어 있다.
    
    DP 테이블의 3번에 담긴 비용인 -8이 1 → 4 → 3 비용인 5보다 작으므로 업데이트 하지 않는다.
    
    | 0 | -6 | -8 | -3 | -15 |
    | --- | --- | --- | --- | --- |
5. **5번 노드,** 3번 노드와 연결되어 있다.
    
    DP 테이블 3번의 -8이 1 → 5 → 3의 비용 -5보다 더 작으므로 업데이트 하지 않는다.
    
    | 0 | -6 | -8 | -3 | -15 |
    | --- | --- | --- | --- | --- |

Iteration1 종료시 [inf, 0, -6, -8, -3, -15]

Iteration2 종료시 [inf, 0, -6, -28, -23, -35]

Iteration3 종료시 [inf, 0, -6, -48, -43, -55]

Iteration4 종료시 [inf, 0, -6, -68, -63, -75]

가되며 마지막으로 여기서 한 번더 수행했을 때 값이 바뀐다면 음의 사이클이 존재하는 것이다.(3번 노드와 5번 노드)

Iteration5 종료시 [inf, 0, -6, -88, -63, -75]

### 구현(Java)

```java
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.PriorityQueue;
import java.util.StringTokenizer;

class Node implements Comparable<Node>{
    int vertex;
    int cost;

    public Node(int vertex, int cost){
        this.vertex = vertex;
        this.cost = cost;
    }

    @Override
    public int compareTo(Node o){
        return Integer.compare(this.cost, o.cost);
    }
}

public class Main {
    static ArrayList<Node>[] graph;

    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));

        StringTokenizer st = new StringTokenizer(br.readLine());

        int vN = Integer.parseInt(st.nextToken());
        int eN = Integer.parseInt(st.nextToken());
        int start = Integer.parseInt(br.readLine());

        graph = new ArrayList[vN + 1];
        for(int i = 0; i <= vN; i++) graph[i] = new ArrayList<>();

        for(int i = 0; i < eN; i++){
            st = new StringTokenizer(br.readLine());
            int v = Integer.parseInt(st.nextToken());
            int w = Integer.parseInt(st.nextToken());
            int cost = Integer.parseInt(st.nextToken());

            graph[v].add(new Node(w, cost));
        }

        dijkstra(vN, start);

    }

    public static void dijkstra(int n, int start){
        boolean[] visited = new boolean[n + 1];
        int dist[] = new int [n + 1];
        int INF = Integer.MAX_VALUE;

        Arrays.fill(dist, INF);
        dist[start] = 0;

        PriorityQueue<Node> pq = new PriorityQueue<>();
        pq.offer(new Node(start, 0));

        while(!pq.isEmpty()){
            int current = pq.poll().vertex;

            if(visited[current]) continue;
            visited[current] = true;

            for(Node next : graph[current]){
                if(dist[next.vertex] > dist[current] + next.cost){
                    dist[next.vertex] = dist[current] + next.cost;
                    pq.offer(new Node(next.vertex, dist[next.vertex]));
                }

            }
        }

        for(int i = 1; i <= n; i++){
            if(dist[i] == INF) System.out.println("INF");
            else System.out.println(dist[i]);
        }
    }
}
```

## **3. 플로이드 워셜 (Floyd Warshall) 알고리즘**

그래프에서 최단 거리를 구하는 알고리즘이다.

시작점을 정해놓고, 해당 시작점에서 다른 모든 노드로의 최단거리를 구하는 **다익스트라**, **벨만-포드 알고리즘**과 다르게 **각각의 모든 노드에 대하여 다른 모든 노드로의 최단거리**를 구할 수 있는 알고리즘

- 모든 노드 간에 최단 경로를 탐색할 수 있다.
- 음수 가중치 간선이 있어도 수행할 수 있다. (음수 사이클은 X)
- 동적 계획법을 이용하여 코드가 비교적 간단하다.
- 다른 알고리즘과 다르게 모든 노드사이의 최단거리를 도출하는 알고리즘이기 때문에 3중 for문을 이용한다.
- 시간 복잡도는 O( N^ 3)이다.

가장 핵심적인 원리

A 노드에서 B까지의 최단경로를 이미 구했는데, 해당 노드가 A -> C -> B의 경로로 이동한다면 A -> C의 최단경로 + C -> B의 최단경로를 통해 이동하게 된다는 것이다.

플로이드 워셜 알고리즘의 핵심은 각 단계마다 특정한 **노드 k**를 **거쳐** 가는 경우를 확인한다. 아래 점화식을 살펴보면 다음과 같다.

$$
D_{ij} = min(D_{ij}, D_{ik} + D_{kj})
$$

i에서 j로 가는 것(Dij)과 i에서 k를 거쳐 j로 가는 것(Dik + Dkj) 중 **어느 것이 최소 비용인지를 찾는 것**이다.

### 동작 예시

<img width="390" height="340" alt="Image" src="https://github.com/user-attachments/assets/15dadb82-d6f0-46d8-ac56-2af60d311b13" />

| 0 | 5 | INF | 7 |
| --- | --- | --- | --- |
| 4 | 0 | -3 | INF |
| 6 | INF | 0 | 4 |
| INF | INF | 2 | 0 |

3중 for문을 사용해 거쳐가는 노드를 설정 후 해당 노드를 거쳐갈 때 비용이 줄어드는 경우 값을 업데이트 시켜줄 것이다. 먼저 거쳐가는(k) 노드가 1일 때의 경우를 살펴보자

1. 노드 1 → (1을 거쳐) → j

    | j | 비교 | 결과 |
    | --- | --- | --- |
    | 1 | 0 vs 0+0 | 변화 없음 |
    | 2 | 5 vs 0+5 | 변화 없음 |
    | 3 | INF vs 0+INF | 변화 없음 |
    | 4 | 7 vs 0+7 | 변화 없음 |
→ 변화 없음

2. i = 2 (노드 2 → (1을 거쳐) → j)

    | j | 비교 | 결과 |
    | --- | --- | --- |
    | 1 | 4 vs 4+0 | 변화 없음 |
    | 2 | 0 vs 4+5=9 | 변화 없음 |
    | 3 | -3 vs 4+INF | 변화 없음 |
    | 4 | INF vs 4+7=11 | **11로 갱신** |

3. i = 3 (노드 3 → (1을 거쳐) → j)

    | j | 비교 | 결과 |
    | --- | --- | --- |
    | 1 | 6 vs 6+0 | 변화 없음 |
    | 2 | INF vs 6+5=11 | **11로 갱신** |
    | 3 | 0 vs 6+INF | 변화 없음 |
    | 4 | 4 vs 6+7=13 | 변화 없음 |

4.  노드 4 → (1을 거쳐) → j

모두 INF + x 형태 (4에서 1을 가는 간선이 X)

→ 변화 없음

**Iteration 1 결과 테이블**

| 0 | 5 | INF | 7 |
| --- | --- | --- | --- |
| 4 | 0 | -3 | **11** |
| 6 | **11** | 0 | 4 |
| INF | INF | 2 | 0 |

이러한 과정을 노드의 수만큼 반복해주면 된다. 이를 요약하면 다음과 같다.

Iteration2는 노드 1~4에서 **노드2**를 거쳐 노드 1~4를 탐색하는 경우가 될 것이다.

Iteration3은 노드 1~4에서 **노드3**을 거쳐 노드 1~4를 탐색하는 경우가 될 것이다.

Iteration4는 노드 1~4에서 **노드4**를 거쳐 노드 1~4를 탐색하는 경우가 될 것이다.

### 구현(Java)

```java
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.StringTokenizer;

/*
sample input(첫 번째 숫자는 노드의 개수, 두 번째 숫자는 간선의 개수 이다).
5
8
0 1 5
0 4 1
0 2 7
0 3 2
1 2 3
1 3 6
2 3 10
3 4 4
 */
public class 플로이드 {
	static int N, M;
	static int[][] dist;

	public static void main(String[] args) throws NumberFormatException, IOException {
		// 초기화
		BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
		N = Integer.parseInt(br.readLine());
		M = Integer.parseInt(br.readLine());
		// 플로이드 초기 거리 테이블 초기화
		dist = new int[N][N];
		for (int i = 0; i < N; i++) {
			for (int j = 0; j < N; j++) {
				// 자기 자신으로 가는 길은 최소 비용이 0이다.
				if (i == j) {
					dist[i][j] = 0;
					continue;
				}
				// 자기 자신으로 가는 경우를 제외하고는 매우 큰 값(N개의 노드를 모두 거쳐서 가더라도 더 큰 값).
				dist[i][j] = 100_000_000;
			}
		}

		for (int i = 0; i < M; i++) {
			StringTokenizer st = new StringTokenizer(br.readLine());
			int a = Integer.parseInt(st.nextToken());
			int b = Integer.parseInt(st.nextToken());
			int cost = Integer.parseInt(st.nextToken());

			// 가는 경로가 하나가 아닐 수 있다. 따라서 그 중 최소 비용을 저장해두면 된다.
			dist[a][b] = Math.min(dist[a][b], cost);
			dist[b][a] = Math.min(dist[b][a], cost);
		}

		// 플로이드 워셜 알고리즘
		// 노드를 1개부터 N개까지 거쳐가는 경우를 모두 고려한다.
		for (int k = 0; k < N; k++) {
			// 노드 i에서 j로 가는 경우.
			for (int i = 0; i < N; i++) {
				for (int j = 0; j < N; j++) {
					// k번째 노드를 거쳐가는 비용이 기존 비용보다 더 작은 경우 갱신
					// 또는 연결이 안되어있던 경우(INF) 연결 비용 갱신.
					dist[i][j] = Math.min(dist[i][j], dist[i][k] + dist[k][j]);
				}
			}
		}

		// 출력
		for (int i = 0; i < N; i++) {
			for (int j = 0; j < N; j++) {
				// 연결이 안되어 있는 경우
				if (dist[i][j] == 100_000_000) {
					System.out.print("INF ");
				} else {
					System.out.print(dist[i][j] + " ");
				}
			}
			System.out.println();
		}
	}
}
```

- 참고 문헌
    
    [[자료 구조] 최단 거리 알고리즘 정리 (다익스트라, 벨만 포드, 플로이드 워셜)](https://roytravel.tistory.com/340)