# 문제
시작 노드에서 다른 모든 노드까지의 최소 거리 구하기

-> 음의 가중치가 없으므로 특정 노드에서 모든 노드까지의 최단거리를 구하는 다익스트라 이용

## Node
```java
class Node implements Comparable<Node>{
    int vertex;
    int cost;

    public Node(int vertex, int cost){
        this.vertex = vertex;
        this.cost = cost;
    }

    @Override
    public int compareTo(Node o){
        return Integer.compare(this.cost, o.cost);
    }
}
```
- v에서 출발하며 w로 도착할 때 w vertex와 v -> w의 cost를 저장하는 Node 클래스
- 우선순위 큐를 이용하기 위해 Comparable을 implements 해주고 기준을 cost로 설정

## graph
```java
static ArrayList<Node>[] graph;

public static void main(String[] args){
    graph = new ArrayList[vN + 1];
    for(int i = 0; i <= vN; i++) graph[i] = new ArrayList<>();
}
```
- 문제에서 주어지는 graph를 저장할 ArrayList<Node>와 초기화

## Dijkstra
```java
    public static void dijkstra(int n, int start){
        boolean[] visited = new boolean[n + 1];
        int dist[] = new int [n + 1];
        int INF = Integer.MAX_VALUE;

        Arrays.fill(dist, INF);
        dist[start] = 0;

        PriorityQueue<Node> pq = new PriorityQueue<>();
        pq.offer(new Node(start, 0));

        while(!pq.isEmpty()){
            int current = pq.poll().vertex;

            if(visited[current]) continue;
            visited[current] = true;

            for(Node next : graph[current]){
                if(dist[next.vertex] > dist[current] + next.cost){
                    dist[next.vertex] = dist[current] + next.cost;
                    pq.offer(new Node(next.vertex, dist[next.vertex]));
                }

            }
        }

        for(int i = 1; i <= n; i++){
            if(dist[i] == INF) System.out.println("INF");
            else System.out.println(dist[i]);
        }
    }
```
- 노드의 방문여부를 확인할 visited 배열 + 최소 비용을 저장할 dist 배열
- 우선순위 큐에 시작 정점을 넣어서 시작 후 시작 노드와 연결된 모든 노드를 우선순위 큐에 넣음
- 우선순위 큐에 따라서 다익스트라 진행 후 문제 형식에 맞게 출력