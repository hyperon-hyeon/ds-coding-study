# 문제
아이들의 키의 합이 놀이기구 키 제한보다 크거나 같을 때 놀이기구를 탈 수 있다. (i + j >= k)

-> 각 날마다 아이들이 놀이기구를 총 몇 번 타는지 출력

## 입력
1. 첫째 줄에 아이들의 수 N, 놀이기구의 수 M, 기간 K, 질문의 개수 Q가 주어진다. (1 ≤ N, M, K, Q ≤ 200,000)
```java
//첫번째 줄 입력 받기
StringTokenizer st = new StringTokenizer(br.readLine());
// 아이들의 수
N = Integer.parseInt(st.nextToken());
// 놀이기구의 수
M = Integer.parseInt(st.nextToken());
// 기간
K = Integer.parseInt(st.nextToken());
// 질문의 개수
Q = Integer.parseInt(st.nextToken());
```
2. 둘째 줄에는 놀이기구들의 키제한이 순서대로 주어진다. (1 ≤ 키제한 ≤ 200,000)
```java
//두번째 줄 입력받기
// 놀이기구 키 제한 입력받기
st = new StringTokenizer(br.readLine());
playMachine = new int[M + 1];
for(int i = 1; i <= M; i++){
    playMachine[i] = Integer.parseInt(st.nextToken());
}
```
3. 셋째 줄에는 각 날에 키가 자라는 아이의 번호가 총 K개 주어진다. (1 ≤ 번호 ≤ N)

    -> 배열로 입력받는 경우 메모리 초과
```java
//세번째 줄 입력받기
// 아이들 키[아이][날짜]
kid = new int[N + 1][K + 1];
st = new StringTokenizer(br.readLine());
for(int day = 1; day <= K; day++){
    int kidNum = Integer.parseInt(st.nextToken());
    kid[kidNum][day] += 1;
    for(int i = day; i <= K; i++){
        kid[kidNum][i] = kid[kidNum][day];
    }
}
```
4. 그 다음 Q줄에 걸쳐 (i, j, k) 쌍이 주어진다. (1 ≤ i, j ≤ N, 1 ≤ k ≤ M)
```java
//네번째 줄 입력받기
// i + j >= k 입력받기
int[][] tryPlay = new int[4][Q + 1];
for(int i = 1; i <= Q; i++){
    st = new StringTokenizer(br.readLine());
    for(int j = 1; j <= 3; j++){
        tryPlay[j][i] = Integer.parseInt(st.nextToken());
    }
}
```

## bnc를 이용한 풀이
```java
int[] ans = new int[Q + 1];
for(int i = 1; i <= Q; i++){
    int a = tryPlay[1][i]; //첫번째 아이
    int b = tryPlay[2][i]; //두번째 아이
    int ride = tryPlay[3][i];
    int limit = playMachine[ride]; //놀이기구 키제한

    int s = 1;
    int e = K;
    while(s <= e){
        int mid = (s + e) / 2;
        if(canRide(a, b, limit, mid)){
            ans[i] = mid;
            e -= 1;
        }
        else{
            s = mid + 1;
        }
    }
}
```
1. 어떤 아이들이 타는지와 놀이기구의 키 제한을 받아온다.
2. bnc를 이용하여 탈 수 있는 가장 빠른 날짜를 구한다.
   - 놀이기구를 탈 수 있다면 더 빠른 날짜가 있는지 확인한다.`e -= 1`
   - 놀이이구를 탈 수 없다면 날짜를 반 늘린다. `s = mid + 1`

## 놀이기구를 탈 수 있는지 체크
```java
public static boolean canRide(int a, int b, int limit, int day) {
    return kid[a][day] + kid[b][day] >= limit;
}
```
## 정답 출력
```java
// 정답 출력
int[] counts = new int[K + 1];

for (int day : ans) {
    if (day >= 1 && day <= K) {
        counts[day]++;
    }
}

int[] sum = new int[K + 1];
for (int i = 1; i <= K; i++) {
    sum[i] = sum[i - 1] + counts[i];
}

for (int i = 1; i <= K; i++) {
    System.out.println(sum[i]);
}
```
- 배열에 [4, 0, 0, 3] 이렇게 저장되어 있는 형식을
- 0, 0, 1, 2 처럼 누적 합으로 바꾸어 출력한다.