## Binary Search(이진 탐색)

**정렬된 배열 또는 리스트에 적합한 고속 탐색 방법**

배열의 중앙에 있는 값을 조사하여 찾고자 하는 항목이 왼쪽 또는 오른쪽 부분 배열에 있는지를 알아내어 탐색의 범위를 반으로 줄임

→ 매 단계에서 검색해야 할 리스트의 크기를 반으로 줄임

주로 고정된 데이터에 대한 탐색에 적합하다.

ex) 10억 명이 정렬된 배열에서 특정 이름찾기

→ 30번의 비교만으로 검색 완료

순차 탐색의 경우 평균 5억 번의 비교가 있어야 된다.

ex) 영어 사전에서 단어를 찾는 과정

## 이진 탐색의 구현

### **1.** 자료들이 **array[low] 에서부터 array[high]에** 들어있다고 가정(**정렬**되어 있어야 함)

어떤 시점에서 탐색되어야 할 범위는 low에서 high 까지

**→ low: 0번 인덱스**, **high: n-1번 인덱스**

### **2.** 중간값 **mid 값은 (low + high) / 2**

→ array[low] ~ array[high] 까지의 탐색은

array[low] ~ array[middle-1] +  array[middle+1] + array[high]까지의 탐색

### **3.** **array[mid] 값과** 구하고자 하는 **key값을 비교**

- **key > mid** :  구하고자 하는 값이 중간값보다 높다면 **low를 mid +1**로 만들어 줌 (왼쪽 반을 버림)
- **key < mid** : 구하고자하는 값이 중간값 보다 낮다면 **high를 mid-1**로 만들어 줌 (오른쪽 반을 버림)
- **key == mid** : 구하고자 하는 값을 찾음 중간값 리턴

### **4.** **low > high가 될 때까지 1~3번을 반복**하면서 구하고자 하는 값을 찾는다.

(이때까지 못 찾으면 탐색 실패 -1, false, error 등 return)

![](https://blog.kakaocdn.net/dna/G7wHv/btqV0D9Zn52/AAAAAAAAAAAAAAAAAAAAADKLtj705DApgwMUKdYLDOAI62aKhTxC8VKUcA-emgbf/img.png?credential=yqXZFxpELC7KVnFOS48ylbz2pIh7yKj8&expires=1764514799&allow_ip=&allow_referer=&signature=q%2FHeYN9EJAAT7jImfJkudUsH72I%3D)

## 순환 호출을 이용한 이진 탐색 구현

```java
int binarySearch1(int key, int low, int high) {
	int mid;

	if(low <= high) {
		mid = (low + high) / 2;

		if(key == arr[mid]) {// 탐색 성공return mid;
		} else if(key < arr[mid]) {
// 왼쪽 부분 arr[0]부터 arr[mid-1]에서의 탐색return binarySearch1(key ,low, mid-1);
		} else {
// 오른쪽 부분 - arr[mid+1]부터 arr[high]에서의 탐색return binarySearch1(key, mid+1, high);
		}
	}

	return -1;// 탐색 실패
}
```

## 

## 반복을 이용한 이진 탐색 구현

반복 구조를 사용하는 것이 재귀 호출로 구현하는 것보다 효율적이다.

![](https://blog.kakaocdn.net/dna/bcXeMW/btqVTH6q09n/AAAAAAAAAAAAAAAAAAAAAB9KrPwMkj4OaeWabLe7O3d5yWrKy8-iWk90EW2C3aRM/img.png?credential=yqXZFxpELC7KVnFOS48ylbz2pIh7yKj8&expires=1764514799&allow_ip=&allow_referer=&signature=eFaINq281dT%2Bhao6%2BB9oYLXV%2FXg%3D)

```java
int binarySearch2(int key, int low, int high) {
	int mid;

	while(low <= high) {
		mid = (low + high) / 2;

		if(key == arr[mid]) {
			return mid;
		} else if(key < arr[mid]) {
			high = mid - 1;
		} else {
			low = mid + 1;
		}
	}

	return -1;// 탐색 실패
}
```

### 참고 문헌

[이진탐색 = 이분탐색 (Binary Search) - Java로 구현](https://minhamina.tistory.com/127)