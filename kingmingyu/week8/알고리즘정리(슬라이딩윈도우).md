## 개념

슬라이딩 윈도우는 연속된 구간(부분 배열)을 하나의 창문처럼 보고, 그 창문을 **오른쪽으로 한 칸씩 밀어가며(슬라이딩)** 문제를 해결하는 방식

(윈도우 내부에 포함된 값들의 집합을 매번 새로 계산X,이전 계산 값을 활용해 빠르게 다음 상태를 구함)

## 사용

- **1차원 배열을 여러 번 반복 탐색해야 하는 문제**
- **연속 구간의 합, 최대 값, 최소 값 등**을 빠르게 구해야 하는 경우
- 반복 탐색을 하면 **O(n × k)** 또는 **O(n²)** 이 걸릴 수 있는 문제
    
    → 슬라이딩 윈도우를 사용하면 **O(n)** 으로 줄임
    

⇒ 이미 계산한 값을 활용해 **중복 계산을 없애는 최적화 기법**

## 동작 방식

### 1. 윈도우 길이가 고정

ex) 길이 5의 연속된 부분 배열의 최대 합 구하기

항상 **5칸짜리 창문**을 유지하면서 오른쪽으로 이동

### 2. 첫 윈도우의 합을 먼저 계산

ex) arr[0] ~ arr[4] 까지 더해서 초기 합 구하기

### 3. 윈도우를 한 칸 이동

새로운 합 = 이전 합 + 새로 들어오는 값 - 창문에서 빠지는 값

ex) 윈도우가 0~4 → 1~5 로 이동할 때

`arr[5]`가 추가, `arr[0]`이 빠짐

---

## **구현 코드**

```java
public static void main() {
    int n = 9; // 배열 크기
    int k = 5; // 윈도우(부분 배열) 길이
    int[] arr = {1, 3, 2, 6, -1, 4, 1, 8, 2};

    int answer = 0; // 최댓값 저장
    int sum = 0;    // 현재 윈도우의 합

    // 1. 첫 번째 윈도우의 합 계산 (arr[0] ~ arr[k-1])
    for (int i = 0; i < k; i++) sum += arr[i];
    answer = sum;

    // 2. 윈도우 이동 (k번째 인덱스부터 n-1까지)
    for (int i = k; i < n; i++) {
        sum += arr[i] - arr[i - k];  // 새 값 더하고, 빠지는 값 빼기
        answer = Math.max(answer, sum);
    }

    System.out.println(answer);
}

```

---

## 코드 설명

### 1. 초기 윈도우 합 계산

```java
for (int i = 0; i < k; i++) sum += arr[i];
```

0번부터 k-1번까지 더하기 → 첫 번째 창문 합

### 2. 윈도우 이동

```java
sum += arr[i] - arr[i - k];
```

- `arr[i]` = 새로 들어오는 값
- `arr[i - k]` = 창문에서 빠지는 값

### 3. 최대값 업데이트

```java
answer = Math.max(answer, sum);
```

매번 가장 큰 윈도우 합을 저장

## 참고 문헌

[[Algorithm] 슬라이딩 윈도우(Sliding Window) 알고리즘 with Java](https://chanhan.tistory.com/entry/Algorithm-%EC%8A%AC%EB%9D%BC%EC%9D%B4%EB%94%A9-%EC%9C%88%EB%8F%84%EC%9A%B0Sliding-Window-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-with-Java)